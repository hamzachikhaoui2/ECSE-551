# -*- coding: utf-8 -*-
"""NaiveBayes.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1326WRN-BPC41M6KNtXuLfgDEudQ7ldKt
"""

# ECSE 551 - MP2  
# Aymen Boustani 260916311 Hamza Chikhaoui 260912960

import numpy as np
from collections import Counter


class NaiveBayes: # Naive Bayes Classifier from scratch

  def __init__(self, laplace): # Constructor function
    #laplace : whether Laplace Smoothing should be applied or not
    
    self.laplace = laplace
    self.probs = {}
    self.outputs = []

  def __str__(self): # Defines a print function associated to the class
    return 'Naive Bayes'

  def fit(self, X, Y): # Fits the model with respect to X and Y
    outputs, probs, size = list(set(Y)), {}, len(Y) # Initiates the list of possible outputs, an empty dictionaries where the odds will be stored as well as the length of the data
    features = np.transpose(X) # gets the transpose of X to get the features in the rows
    for o in outputs:
      count = Counter(Y[i] == o for i in range(size))[1] 
      probs[f'Y = {o}'] = count / size # Sets P(Y = y)
      for i in range(len(features)):
        for u in set(features[i]):
          if self.laplace:
            probs[f'X{i} = {u} | {o}'] = (Counter(features[i][j] == u and Y[j] == o for j in range(size))[1] + 1) / (count + 2) # Sets P(X = x | y) 
          else:
            probs[f'X{i} = {u} | {o}'] = Counter(features[i][j] == u and Y[j] == o for j in range(size))[1] / count # Same
    self.outputs = outputs
    self.probs = probs

  def predict(self, X, labels = None): # For a set of vectors X, the function predicts a label for each vector in X
    # labels : if labels are given, the function return the label(city); if not the integer that corresponds to the label
    predictions = []
    for x in X:
      compare = {}
      for o in self.outputs:
        prob = self.probs[f'Y = {o}']
        for i in range(len(x)):
          prob *= self.probs[f'X{i} = {int(x[i])} | {o}']
        compare[o] = prob
      if labels is not None:
        predictions.append(labels[max(compare, key = compare.get)])
      else:
        predictions.append(max(compare, key = compare.get))
    return predictions
